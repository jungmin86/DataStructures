// Implementation file for Unsorted.h#include "unsorted.h"UnsortedType::UnsortedType(){  length = 0;}bool UnsortedType::IsFull() const{  return (length == MAX_ITEMS);}int UnsortedType::LengthIs() const{  return length;}void UnsortedType::RetrieveItem(ItemType& item, bool& found) // Pre:  Key member(s) of item is initialized. // Post: If found, item's key matches an element's key in the //       list and a copy of that element has been stored in item; //       otherwise, item is unchanged. {  bool moreToSearch;  int location = 0;  found = false;  moreToSearch = (location < length);  while (moreToSearch && !found)   {    switch (item.ComparedTo(info[location]))    {      case LESS    :       case GREATER : location++;                     moreToSearch = (location < length);                     break;      case EQUAL   : found = true;                     item = info[location];                     break;    }  }}void UnsortedType::InsertItem(ItemType item)// Post: item is in the list.{  info[length] = item;  length++;}void UnsortedType::DeleteItem(ItemType item)// Pre:  item's key has been initialized.//       An element in the list has a key that matches item's.// Post: No element in the list has a key that matches item's.{  int location = 0;  while (item.ComparedTo(info[location]) != EQUAL) //반복문의 조건을 이렇게 걸면 locationdl length를 넘어갈 텐데?    location++;  info[location] = info[length - 1];  length--;}void UnsortedType::DeleteItem_a(ItemType item){    bool deleted = false; //한 번이라도 지워지면 더 이상 안지워야 함    for (int i = 0; i < length && !deleted; i++) //for문을 통해 검색횟수 제한    {        if(item.ComparedTo(info[i]) == EQUAL){            // 해당 아이템을 삭제            info[i] = info[length-1]; //마지막 요소를 삭제된 위치로 할당            length--; //length를 줄여줌으로써 마지막 요소는 가비지 데이터가 됨            deleted = true;            break;        }    }}void UnsortedType::DeleteItem_c(ItemType item){    int i = 0;    while (i < length) { // lengt를 넘어갈 일 없음        if(item.ComparedTo(info[i]) == EQUAL){            // 해당 아이템을 삭제            // 삭제 후 현재 i 위치의 값이 변경되었으므로 나중에 다시 확인 하도록            // i 값 변경 하지 않음 , 추가로 length값은 감소            info[i] = info[length-1];            length--;                    }        else {            // 다음 아이템을 보기 위해서 i값 변경            i++;        }    }}void UnsortedType::ResetList()// Post: currentPos has been initialized.{  currentPos = -1;}void UnsortedType::GetNextItem(ItemType& item)// Post: item is current item.//       Current position has been updated.{  currentPos++;  item = info[currentPos];}