#include "QueType.h"#include <iostream>QueType::QueType(int max) //max -> 최대 인덱스 번호// Parameterized class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = max + 1; //개수를 나타내는 것 = 총 인덱스 + 1  front = maxQue - 1;  rear = maxQue - 1;  items = new ItemType[maxQue];}QueType::QueType()          // Default class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = 501;  front = maxQue - 1;  rear = maxQue - 1;  items = new ItemType[maxQue];}QueType::~QueType()         // Class destructor{  delete [] items;}void QueType::MakeEmpty()// Post: front and rear have been reset to the empty state.{  front = maxQue - 1;  rear = maxQue - 1;}bool QueType::IsEmpty() const// Returns true if the queue is empty; false otherwise.{  return (rear == front);}bool QueType::IsFull() const// Returns true if the queue is full; false otherwise.{  return ((rear + 1) % maxQue == front);}void QueType::Enqueue(ItemType newItem)// Post: If (queue is not full) newItem is at the rear of the queue;//       otherwise a FullQueue exception is thrown.  {  if (IsFull())    throw FullQueue();  else  {    rear = (rear +1) % maxQue;    items[rear] = newItem;  }}void QueType::Dequeue(ItemType& item)// Post: If (queue is not empty) the front of the queue has been //       removed and a copy returned in item; //       othersiwe a EmptyQueue exception has been thrown.{  if (IsEmpty())    throw EmptyQueue();  else  {    front = (front + 1) % maxQue;    item = items[front];  }}bool QueType::Identical (const QueType& qt) {    if (maxQue != qt.maxQue) return false;    for (int i = 0; i < maxQue; i++) {        if(this->items[i] != qt.items[i]) return false;    }    return true;}//B.int QueType::Length() {    if (this-> IsEmpty()) return 0;    else if (this -> IsFull()) return maxQue - 1;    else if (rear > front) return (rear - front);    else {std::cout<<"d"; return (maxQue-(front - rear));}}void QueType::Print() {    for (int i = (front+1)%maxQue ; i != (rear+1)%maxQue; i = (i+1)%maxQue) {        std::cout << items[i] << " ";    }}