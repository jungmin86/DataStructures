#include "QueType.h"#include <iostream>QueType::QueType(int max)// Parameterized class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = max + 1;  front = maxQue - 1;  rear = maxQue - 1;    minimum_pos = -1;    length = 0;  items = new ItemType[maxQue];}QueType::QueType()          // Default class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = 501;  front = maxQue - 1;  rear = maxQue - 1;    minimum_pos = -1;    length = 0;  items = new ItemType[maxQue];}QueType::~QueType()         // Class destructor{  delete [] items;}void QueType::MakeEmpty()// Post: front and rear have been reset to the empty state.{  front = maxQue - 1;  rear = maxQue - 1;    minimum_pos = -1;    length = 0;}bool QueType::IsEmpty() const// Returns true if the queue is empty; false otherwise.{    return (length == 0);}bool QueType::IsFull() const// Returns true if the queue is full; false otherwise.{  return (length == maxQue);}void QueType::Enqueue(ItemType newItem){  if (IsFull())    throw FullQueue();  else  {      if(IsEmpty()) {          rear = (rear + 1) % maxQue;          items[rear] = newItem;          minimum_pos = rear; //처음 넣은 게 가장 작은 수      }      else {//비어있지 않을 때          int i = (front+1) % maxQue;          while (i != (rear+1)%maxQue) { //-1이 존재하는 경우 확인              if (items[i] == -1) { //-1이 존재하는 경우                  items[i] = newItem;                  if (newItem < items[minimum_pos]) minimum_pos = rear;                  break;              }               i = (i+1) % maxQue;          }          rear = (rear + 1) % maxQue; //비어있지 않은데 -1이 없는 경우          items[rear] = newItem;          if (newItem < items[minimum_pos]) minimum_pos = rear;      }  } length++;}void QueType::Dequeue(ItemType& item)// Post: If (queue is not empty) the front of the queue has been //       removed and a copy returned in item; //       othersiwe a EmptyQueue exception has been thrown.{  if (IsEmpty())    throw EmptyQueue();  else  {      length--;    front = (front + 1) % maxQue;    item = items[front];  }}bool QueType::Identical (const QueType& qt) {    if (maxQue != qt.maxQue) return false;    for (int i = 0; i < maxQue; i++) {        if(this->items[i] != qt.items[i]) return false;    }    return true;}int QueType::Length() {    if (this-> IsEmpty()) return 0;    else if (this -> IsFull()) return maxQue - 1;    else if (rear > front) return (rear - front);    else return (maxQue-(front - rear));}void QueType::MinDequeue(ItemType& item) {    if (IsEmpty())        throw EmptyQueue();    else {        item = items[minimum_pos]; //현재 가장 작은 수 반환        items[minimum_pos] = -1; //-1로 바꾼다.                int i = (front + 1) % maxQue;        minimum_pos = i;        while (i != (rear+1)%maxQue) {            if ((items[i] < items[minimum_pos]) && (items[i] != -1)) {                minimum_pos = i;                break;            }            i = (i+1) % maxQue;        }    } length--;}