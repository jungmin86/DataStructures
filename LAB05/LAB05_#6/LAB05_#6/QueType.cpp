#include "QueType.h"#include <iostream>QueType::QueType(int max)// Parameterized class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = max + 1;  front = maxQue - 1;  rear = maxQue - 1;    length = 0;    minimum_pos = -1;  items = new ItemType[maxQue];}QueType::QueType()          // Default class constructor// Post: maxQue, front, and rear have been initialized.//       The array to hold the queue elements has been dynamically//       allocated.{  maxQue = 501;  front = maxQue - 1;  rear = maxQue - 1;    length = 0;    minimum_pos = -1;  items = new ItemType[maxQue];}QueType::~QueType()         // Class destructor{  delete [] items;}void QueType::MakeEmpty()// Post: front and rear have been reset to the empty state.{  front = maxQue - 1;  rear = maxQue - 1;    length = 0;    minimum_pos = -1;}bool QueType::IsEmpty() const// Returns true if the queue is empty; false otherwise.{  return (length == 0);}bool QueType::IsFull() const// Returns true if the queue is full; false otherwise.{  return (length == maxQue);}void QueType::Enqueue(ItemType newItem)// Post: If (queue is not full) newItem is at the rear of the queue;//       otherwise a FullQueue exception is thrown.  {  if (IsFull())    throw FullQueue();  else  {      bool found = false; //-1 존재하는지 여부      int i = (front+1) % maxQue;      while ( !found && i != rear) { //-1이 존재하는지 확인          if (items[i] == -1) {              items[i] = newItem;              if(newItem < items[minimum_pos]) {                  minimum_pos = i;                  found =true;              }          } i = (i+1) % maxQue;      }      if(!found) { //-1이 없을 떄          rear = (rear + 1) % maxQue;          if (length == 0) minimum_pos = rear;          items[rear] = newItem;          if (newItem < items[minimum_pos]) minimum_pos = rear;      }      length++;  }}void QueType::Dequeue(ItemType& item)// Post: If (queue is not empty) the front of the queue has been //       removed and a copy returned in item; //       othersiwe a EmptyQueue exception has been thrown.{  if (IsEmpty())    throw EmptyQueue();  else  {      length--;    front = (front + 1) % maxQue;    item = items[front];  }}bool QueType::Identical (const QueType& qt) {    if (maxQue != qt.maxQue) return false;    for (int i = 0; i < maxQue; i++) {        if(this->items[i] != qt.items[i]) return false;    }    return true;}int QueType::Length() {    if (this-> IsEmpty()) return 0;    else if (this -> IsFull()) return maxQue - 1;    else if (rear > front) return (rear - front);    else return (maxQue-(front - rear));}void QueType::MinDequeue(ItemType& item) {    if (IsEmpty())        throw EmptyQueue();    else {        item = items[minimum_pos];        items[minimum_pos] = -1;        int i = (front + 1) % maxQue;        minimum_pos = i;        while (i != rear) {            if (items[i] != -1 && items[i] < items[minimum_pos]) {                minimum_pos = i;            }            i = (i + 1) % maxQue;        }        length--;    }}