// The class definition for StackType using templates class FullStack// Exception class thrown by Push when stack is full.{};class EmptyStack// Exception class thrown by Pop and Top when stack is emtpy.{};#include <iostream>const int MAX_ITEMS = 200;class DoubleStack{public:    DoubleStack();    // Class constructor.    bool IsFull() const;    // Function: Determines whether the stack is full.    // Pre:  Stack has been initialized.    // Post: Function value = (stack is full)    bool IsEmpty() const;    // Function: Determines whether the stack is empty.    // Pre:  Stack has been initialized.    // Post: Function value = (stack is empty)    void Push(int);    // Function: Adds newItem to the top of the stack.    // Pre:  Stack has been initialized.    // Post: If (stack is full), FullStack exception is thrown;    //       otherwise, newItem is at the top of the stack.    void Pop();    // Function: Removes top item from the stack.    // Pre:  Stack has been initialized.    // Post: If (stack is empty), EmptyStack exception is thrown;    //       otherwise, top element has been removed from stack.    int Top();    // Function: Returns a copy of top item on the stack.    // Pre:  Stack has been initialized.    // Post: If (stack is empty), EmptyStack exception is thrown;    //       otherwise, top element has been removed from stack.    void Print();           private:    int top_small;    int top_big;    int  items[MAX_ITEMS];};// The function definitions for class StackType.// The function definitions for class StackType.DoubleStack::DoubleStack(){    top_small = -1;    top_big = MAX_ITEMS;}bool DoubleStack::IsEmpty() const{  return (top_small == -1)&&(top_big == 200);}bool DoubleStack::IsFull() const{    return (top_big == top_small + 1);}void DoubleStack::Push(int value){    if (IsFull())        throw FullStack();    else if (value <= 1000) {        top_small++;        items[top_small] = value;    }    else {        top_big--;        items[top_big] = value;    }    }void DoubleStack::Print() {    //    while (!(top_small == -1)) {//        std::cout << items[top_small] << " ";//        top_small--;//    }//    while (!(top_big == MAX_ITEMS)) {//        std::cout << items[top_big] << " ";//        top_big++;//    }    int small_loc;    int big_loc;    for (small_loc = 0; small_loc <= top_small; small_loc++) {        std::cout << items[small_loc] << " ";    }    for (big_loc = MAX_ITEMS-1; big_loc >= top_big; big_loc-- ) {        std::cout << items[big_loc] << " ";    }}//void DoubleStack::Pop()//{//  if( IsEmpty() )//    throw EmptyStack();//  top--;//}////int DoubleStack::Top()//{//  if (IsEmpty())//    throw EmptyStack();//  return items[top];//}